'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var S = _interopDefault(require('s-js'));

function comparer(v, k, b, isArray, path, r) {
  let ref, ref1;
  const newPath = path.concat([k]);
  if (isArray && !(((v != null ? v.id : void 0) && (v != null ? v.id : void 0) === ((ref = b[k]) != null ? ref.id : void 0)) || ((v != null ? v._id : void 0) && (v != null ? v._id : void 0) === ((ref1 = b[k]) != null ? ref1._id : void 0))) || !((v != null) && ((b != null ? b[k] : void 0) != null) && (v instanceof Object))) {
    return r.push(newPath.concat([v]));
  }
  return r.push.apply(r, diff(v, b[k], newPath));
}

function resolveAsync(value, fn) {
  if (!isObject(value)) return fn(value);
  if ('subscribe' in value) {
    const dispose = value.subscribe(fn);
    S.cleanup(function disposer() { dispose.unsubscribe(); });
    return;
  }
  if ('then' in value) {
    value.then(fn);
    return;
  }
  fn(value);
}

function isObject(obj) {
  let ref;
  return obj !== null && ((ref = typeof obj) === 'object' || ref === 'function');
}

function diff(a, b, path = []) {
  let i, k, l, len, v;
  const r = [];
  if (!isObject(a) || (b == null)) {
    if (a !== b) {
      r.push(path.concat([a]));
    }
  } else if (Array.isArray(a)) {
    for (k = i = 0, len = a.length; i < len; k = ++i) {
      v = a[k];
      if ((b != null ? b[k] : void 0) !== v) comparer(v, k, b, true, path, r);
    }
    if ((b != null ? b.length : void 0) > a.length) {
      l = a.length;
      while (l < b.length) {
        r.push(path.concat([l, void 0]));
        l++;
      }
    }
  } else {
    for (k in a) {
      v = a[k];
      if ((b != null ? b[k] : void 0) !== v)
        comparer(v, k, b, false, path, r);
    }
    for (k in b) {
      v = b[k];
      if (!(k in a))
        r.push(path.concat([k, void 0]));
    }
  }
  return r;
}

function unwrap(item, depth) {
  let keys, result, unwrapped, v;
  if (result = item != null ? item._state : void 0) return result;

  if (!depth || !isObject(item) || (typeof item === 'function') || (item instanceof Element)) return item;

  keys = Object.keys(item);
  for (let i = 0, l = keys.length; i < l; i++) {
    v = item[keys[i]];
    if ((unwrapped = unwrap(v, depth - 1)) !== v) item[keys[i]] = unwrapped;
  }
  return item;
}

function clone(v) {
  if (!isObject(v)) return v;

  if (Array.isArray(v)) return v.slice(0);

  return Object.assign({}, v);
}

function select() {
  const mapFn1 = selection => () => {
    const unwrapped = unwrap(selection(), 10),
      results = [];
    resolveAsync(unwrapped, (value) => {
      if (value === void 0) return;
      for (let key in value || {}) {
        results.push(diff(value[key], this._state[key], [key]));
      }
      this.replace([].concat(...results));
    });
  };

  const mapFn2 = (key, selector) => () => {
    const unwrapped = unwrap(selector(), 10);
    resolveAsync(unwrapped, (value) => {
      if (value === void 0) return;
      this.replace(diff(value, this._state[key], [key]));
    });
  };

  for (let i = 0; i < arguments.length; i++) {
    const selection = arguments[i];
    if (typeof selection === 'function') {
      S.makeComputationNode(mapFn1(selection));
      continue;
    }
    for (let key in selection) {
      if (!(key in this)) this._defineProperty(key);
      S.makeComputationNode(mapFn2(key, selection[key]));
    }
  }
  return this;
}

function getDataNode(target) {
  if (!('_S' in target)) {
    Object.defineProperty(target, '_S', { value: {} });
  }
  return target._S;
}

function trigger(node, property, notify) {
  if (node[property]) node[property].next();
  if (notify && node._self) node._self.next();
}

function track(target, property) {
  let value = target[property], node;
  if (Object.isFrozen(value)) {
    value = clone(value);
    target[property] = value;
  }
  if (isObject(value) && !(value instanceof Element)) {
    if (node = getDataNode(value)) {
      if (!node._self) node._self = S.makeDataNode();
      node._self.current();
    }
  }
  node = getDataNode(target);
  node[property] || (node[property] = S.makeDataNode());
  node[property].current();
}

function setNested(item, changes) {
  let node = getDataNode(item),
    isArray = Array.isArray(item),
    value, notify, keys;

  if (arguments.length === 3) {
    notify = isArray || !(arguments[1] in item);
    value = unwrap(arguments[2]);
    if (item[arguments[1]] === value) return;
    if (value === void 0) {
      delete item[arguments[1]];
      if (isArray) item.length--;
    } else item[arguments[1]] = value;

    trigger(node, arguments[1], notify);
    return;
  }

  keys = Object.keys(changes);
  for (let i = 0, l = keys.length; i < l; i++) {
    const property = keys[i];
    notify = isArray || !(property in item);
    value = unwrap(changes[property]);
    if (value === void 0) delete item[property];
    else item[property] = value;
    trigger(node, property, notify);
  }
}

function resolvePath(current, path, length) {
  let i = 0, temp;
  while (i < length && (temp = current[path[i]]) != null) {
    current = temp;
    i++;
  }
  return current;
}

function sample(target, property) {
  let value = target[property];

  // don't wrap
  if (!isObject(value) || value instanceof Element) return value;
  return new Proxy(value, proxyTraps);
}

const proxyTraps = {
  get(target, property) {
    if (property === '_state') return target;
    if (property === 'sample') return sample.bind(null, target);
    let value = target[property];
    if (property === 'length' || typeof property === 'symbol') return value;
    if (!S.isListening() || typeof value === 'function') return value;
    track(target, property);
    return sample(target, property);
  },

  set() { return true; },

  deleteProperty() { return true; }
};

class State {
  constructor(state = {}) {
    Object.defineProperties(this, {
      _state: { value: state, writable: true }
    });
    this.sample = sample.bind(this, state);
    for (let k in this._state) this._defineProperty(k);
  }

  set() {
    const args = arguments;
    S.freeze(() => {
      if (args.length === 1) {
        if (Array.isArray(args[0])) {
          for (let i = 0; i < args[0].length; i++) this.set.apply(this, args[0][i]);
        } else {
          const keys = Object.keys(args[0]);
          for (let i = 0, l = keys.length; i < l; i++) {
            const property = keys[i];
            this._setProperty(property, args[0][property]);
          }
        }
        return;
      }

      setNested(resolvePath(this._state, args, args.length - 1), args[args.length - 1]);
    });
    return this;
  }

  replace() {
    if (arguments.length === 1) {
      if (!(arguments[0] instanceof Object)) {
        console.log('replace must be provided a replacement state');
        return this;
      }
      let changes = arguments[0];
      S.freeze(() => {
        if (!(Array.isArray(changes))) changes = diff(changes, this._state);

        for (let i = 0; i < changes.length; i++) this.replace.apply(this, changes[i]);
      });
      return this;
    }

    if (arguments.length === 2) {
      this._setProperty.apply(this, arguments);
      return this;
    }

    const value = arguments[arguments.length - 1],
      property = arguments[arguments.length - 2];
    setNested(resolvePath(this._state, arguments, arguments.length - 2), property, value);
    return this;
  }

  _setProperty(property, value) {
    if (!(property in this)) this._defineProperty(property);
    value = unwrap(value);
    if ( this._state[property] === value) return;
    if (value === void 0) delete this._state[property];
    else this._state[property] = value;
    trigger(getDataNode(this._state), property);
  }

  _defineProperty(property) {
    Object.defineProperty(this, property, {
      get() {
        const value = this._state[property];
        if (!S.isListening() || typeof value === 'function') return value;
        track(this._state, property);
        return sample(this._state, property);
      },
      enumerable: true
    });
  }
}

State.prototype.select = select;

var clockTime = 0;

function track$1(target, property, key) {
  target[property][key] || (target[property][key] = S.makeDataNode());
  target[property][key].current();
}

function register(target, property) {
  if (!target[property]) {
    target[property] = {
      _root: target._root || target,
      _clock: clockTime,
      _path: target._path.concat([property]),
      _state: target._state[property]
    };
  }
}

function sample$1(target, property) {
  let value = target._state[property];
  if (isObject(value) && !(value instanceof Element)) {
    register(target, property);
    value = new Proxy(target[property], proxyTraps$1);
  }
  return value;
}

function resolveState(target) {
  var current = target._root._state,
    i = 0,
    l = target._path.length;
  while (i < l) {
    if (current) current = current[target._path[i]];
    i++;
  }
  target._state = current;
  target._clock = clockTime;
}

const proxyTraps$1 = {
  set() { return true; },

  deleteProperty() { return true; },

  has(target, property) {
    if (target._clock < clockTime) resolveState(target);
    return Reflect.has(target._state, property);
  },

  ownKeys(target) {
    if (target._clock < clockTime) resolveState(target);
    return Reflect.ownKeys(target._state);
  },

  getOwnPropertyDescriptor(target, property) {
    if (target._clock < clockTime) resolveState(target);
    var descriptors = Reflect.getOwnPropertyDescriptor(target._state, property);
    // hack for invariant
    descriptors.configurable = true;
    return descriptors;
  },

  get(target, property) {
    var value;
    if (target._clock < clockTime) resolveState(target);
    if (property === '_state') return target._state;
    if (property === 'sample') return sample$1.bind(null, target);
    if (property === 'length' || typeof property === 'symbol') return target._state[property];
    if (property.endsWith('$')) {
      property = property.slice(0, -1);
      value = target._state[property];
      if (!S.isListening() || typeof value === 'function') return value;
      register(target, property);
      track$1(target, property, '_subTree');
      return value;
    }
    value = target._state[property];
    if (!S.isListening() || typeof value === 'function') return value;
    register(target, property);
    track$1(target, property, '_self');
    if (isObject(value) && !(value instanceof Element)) value = new Proxy(target[property], proxyTraps$1);
    return value;
  }
};

class ImmutableState {
  constructor(state = {}) {
    Object.defineProperties(this, {
      _state: {value: state, writable: true},
      _nodes: {value: {_path: [], _state: state}, writable: true}
    });
    this.select = select.bind(this);
    this.sample = sample$1.bind(this, this._nodes);
    for (var k in this._state) this._defineProperty(k);
  }

  set() {
    var args = arguments, ref,
      clearMutation = !ImmutableState.inMutation;
    if (clearMutation) clockTime++;
    ImmutableState.inMutation = true;
    S.freeze(() => {
      if (args.length === 1) {
        if (Array.isArray(args[0]))
          for (let i = 0; i < args[0]; i++)
            this.set.apply(this, args[0][i]);
        else
          for (let property in args[0])
            this._setProperty(property, args[0][property]);
        return;
      }
      var changes = args[args.length - 1],
        notify, value, property,
        {state, subs, subPaths} = this._resolvePath(args, args.length - 1);
      if (!state) return;
      notify = Array.isArray(state);
      for (property in changes) {
        value = unwrap(changes[property]);
        if (state[property] === value) continue;
        notify = notify || !(property in state);
        if (value === void 0)
          delete state[property];
        else state[property] = value;
        if (subs)
          (ref = subs[property]) != null && ref._self ? ref._self.next() : void 0;
      }
      if (notify && subs && subs._self) subs._self.next();
      for (let i = 0; i < subPaths.length; i++) subPaths[i].next();
    });
    if (clearMutation) ImmutableState.inMutation = false;
    return this;
  }

  replace() {
    var ref,
      clearMutation = !ImmutableState.inMutation;
    if (clearMutation) clockTime++;
    ImmutableState.inMutation = true;
    if (arguments.length === 1) {
      if (!(arguments[0] instanceof Object)) {
        console.log('replace must be provided a replacement state');
        if (clearMutation) ImmutableState.inMutation = false;
        return this;
      }
      var changes = arguments[0];
      S.freeze(() => {
        if (!(Array.isArray(changes))) changes = diff(changes, this._state);

        for (let i = 0; i < changes.length; i++) this.replace.apply(this, changes[i]);
      });
      if (clearMutation) ImmutableState.inMutation = false;
      return this;
    }

    if (arguments.length === 2) {
      this._setProperty.apply(this, arguments);
      if (clearMutation) ImmutableState.inMutation = false;
      return this;
    }

    var value = unwrap(arguments[arguments.length - 1]),
      property = arguments[arguments.length - 2],
      notify,
      {state, subs, subPaths} = this._resolvePath(arguments, arguments.length - 2);
    if (!state || state[property] === value) return;
    if (value === void 0 && Array.isArray(state)) {
      state.length -= 1;
      notify = true;
    } else {
      notify = Array.isArray(state) || !(property in state);
      if (value === void 0)
        delete state[property];
      else state[property] = value;
    }
    if (subs && subs[property] && (ref = subs[property]._self)) ref.next();
    if (notify && subs && subs._self) subs._self.next();
    for (let i = 0; i < subPaths.length; i++) subPaths[i].next();
    if (clearMutation) ImmutableState.inMutation = false;
    return this;
  }

  _resolvePath(path, length) {
    var currentState = this._state,
      currentSubs = this._nodes,
      subPaths = [],
      i = 0;
    while (i < length) {
      register(currentSubs, path[i]);
      currentSubs = currentSubs[path[i]];

      if (currentState != null) {
        if (currentSubs._clock !== clockTime) {
          currentState[path[i]] = clone(currentState[path[i]]);
          currentSubs._clock = clockTime;
          currentSubs._state = currentState[path[i]];
        }
        currentState = currentState[path[i]];
      }

      if ((currentSubs != null ? currentSubs._subTree : void 0) != null)
        subPaths.push(currentSubs._subTree);
      i++;
    }
    return {state: currentState, subs: currentSubs, subPaths};
  }

  _setProperty(property, value) {
    var ref;
    if (!(property in this)) this._defineProperty(property);
    value = unwrap(value);
    if ( this._state[property] === value) return;
    if (value === void 0)
      delete this._state[property];
    else this._state[property] = value;
    (ref = this._nodes[property]) != null && ref._self ? ref._self.next() : void 0;
    ref && ref._subTree ? ref._subTree.next() : void 0;
  }

  _defineProperty(property) {
    Object.defineProperty(this, property, {
      get() {
        var value = this._state[property];
        if (!S.isListening() || typeof value === 'function') return value;
        register(this._nodes, property);
        track$1(this._nodes, property, '_self');
        if (isObject(value) && !(value instanceof Element)) value = new Proxy(this._nodes[property], proxyTraps$1);
        return value;
      },
      enumerable: true
    });

    Object.defineProperty(this, property + '$', {
      get() {
        var value = this._state[property];
        if (!S.isListening()) return value;
        register(this._nodes, property);
        track$1(this._nodes, property, '_subTree');
        return value;
      }
    });
  }
}

ImmutableState.inMutation = false;

function fromPromise(promise, seed) {
  let s = S.makeDataNode(seed),
    complete = false;
  promise
    .then((value) => {
      if (complete) return;
      s.next(value);
    }).catch(err => console.error(err));

  S.cleanup(function dispose() { complete = true; });
  return () => s.current();
}

function fromObservable(observable, seed) {
  let s = S.makeDataNode(seed),
    disposable = observable.subscribe(v => s.next(v), err => console.error(err));

  S.cleanup(function dispose() {
    disposable.unsubscribe();
    disposable = null;
  });
  return () => s.current();
}

function from(input, seed) {
  if (isObject(input)) {
    if (typeof input === 'function') return input;
    if (Symbol.observable in input) return fromObservable(input[Symbol.observable](), seed);
    if ('then' in input) return fromPromise(input, seed);
  }
  throw new Error('from() input must be a function, Promise, or Observable');
}

function pipe(input, ...fns) {
  return compose(...fns)(input);
}

function map(fn) {
  return input => () => {
    const value = input();
    if (value === void 0) return;
    return S.sample(() => fn(value));
  }
}

function compose(...fns) {
  if (!fns) return i => i;
  if (fns.length === 1) return fns[0];
  return input => fns.reduce(((prev, fn) => fn(prev)), input);
}

// memoized map that handles falsey rejection
function when(mapFn) {
  let mapped, value, disposable;
  S.cleanup(function dispose() {
    disposable && disposable();
  });
  return map(function mapper(newValue) {
    if (newValue == null || newValue === false) {
      disposable && disposable();
      return value = mapped = disposable = null;
    }
    if (value === newValue) return mapped;
    disposable && disposable();
    disposable = null;
    value = newValue;
    return mapped = S.root((d) => {
      disposable = d;
      return mapFn(value);
    });
  })
}

// Need to be able grab wrapped state internals so can't use S-Array
function each(mapFn) {
  let mapped = [],
      list = [],
      disposables = [],
      length = 0;
  S.cleanup(function dispose() {
    for (let i = 0; i < disposables.length; i++) disposables[i]();
  });
  return map(function mapper(newList) {
    let newListUnwrapped = unwrap(newList, 1), i, j = 0,
      newLength = (newListUnwrapped && newListUnwrapped.length) || 0;
    if (newLength === 0) {
      if (length !== 0) {
        for (i = 0; i < length; i++) disposables[i]();
        list = [];
        mapped = [];
        disposables = [];
        length = 0;
      }
    } else if (length === 0) {
      j = 0;
      while (j < newLength) {
        list[j] = newListUnwrapped[j];
        mapped[j] = S.root(mappedFn);
        j++;
      }
      length = newLength;
    } else {
      const newMapped = new Array(newLength),
        tempDisposables = new Array(newLength),
        indexedItems = new Map();

      // reduce from both ends
      let end = Math.min(length, newLength),
        start = 0, item, itemIndex, newEnd;
      while (start < end && newListUnwrapped[start] === list[start]) start++;

      end = length - 1;
      newEnd = newLength - 1;
      while (end >= 0 && newEnd >= 0 && newListUnwrapped[newEnd] === list[end]) {
        newMapped[newEnd] = mapped[end];
        tempDisposables[newEnd] = disposables[end];
        end--;
        newEnd--;
      }

      // create indices
      j = newEnd;
      while (j >= start) {
        item = newListUnwrapped[j];
        itemIndex = indexedItems.get(item);
        if (itemIndex != null) itemIndex.push(j);
        else indexedItems.set(item, [j]);
        j--;
      }

      // find old items
      i = start;
      while (i <= end) {
        item = list[i];
        itemIndex = indexedItems.get(item);
        if (itemIndex != null && itemIndex.length > 0) {
          j = itemIndex.pop();
          newMapped[j] = mapped[i];
          tempDisposables[j] = disposables[i];
        } else disposables[i]();
        i++;
      }

      // set all new values
      j = start;
      while (j < newLength) {
        if (newMapped.hasOwnProperty(j)) {
          mapped[j] = newMapped[j];
          disposables[j] = tempDisposables[j];
        } else mapped[j] = S.root(mappedFn);
        j++;
      }

      // truncate extra length
      length = mapped.length = disposables.length = newLength;
      // save list for next iteration
      list = newListUnwrapped.slice(0);
    }
    return mapped;

    function mappedFn(dispose) {
      let ref;
      disposables[j] = dispose;
      const row = (ref = newList.sample) ? ref(j) : newList[j];
      return mapFn(row, j);
    }
  });
}

// export observable
function observable(input) {
  if (Symbol.observable in input) return input[Symbol.observable]();
  return {
    subscribe(observer) {
      if (!(observer instanceof Object) || observer == null) {
        throw new TypeError('Expected the observer to be an object.');
      }
      observer = observer.next || observer;
      let complete = false;
      S.on(input, function next() {
        if (complete) return;
        observer(input());
      });
      return {
        unsubscribe() { complete = true; }
      };
    },
    [Symbol.observable]() { return this; }
  };
}

const root = S.root;
const cleanup = S.cleanup;

exports.root = root;
exports.cleanup = cleanup;
exports.State = State;
exports.ImmutableState = ImmutableState;
exports.unwrap = unwrap;
exports.from = from;
exports.pipe = pipe;
exports.map = map;
exports.compose = compose;
exports.when = when;
exports.each = each;
exports.observable = observable;
